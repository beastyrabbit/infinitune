import { defineSchema, defineTable } from 'convex/server'
import { v } from 'convex/values'
import { llmProviderValidator, playlistModeValidator, playlistStatusValidator, songStatusValidator } from './types'

export default defineSchema({
  playlists: defineTable({
    name: v.string(),
    prompt: v.string(),
    llmProvider: llmProviderValidator,
    llmModel: v.string(),
    mode: v.optional(playlistModeValidator),
    status: playlistStatusValidator,
    songsGenerated: v.number(),
    playlistKey: v.optional(v.string()),
    lyricsLanguage: v.optional(v.string()),
    targetBpm: v.optional(v.number()),
    targetKey: v.optional(v.string()),
    timeSignature: v.optional(v.string()),
    audioDuration: v.optional(v.number()),
    inferenceSteps: v.optional(v.number()),
    lmTemperature: v.optional(v.number()),
    lmCfgScale: v.optional(v.number()),
    inferMethod: v.optional(v.string()),
    currentOrderIndex: v.optional(v.number()),
    lastSeenAt: v.optional(v.number()),
    promptEpoch: v.optional(v.number()),
    steerHistory: v.optional(v.array(v.object({
      epoch: v.number(),
      direction: v.string(),
      at: v.number(),
    }))),
  }).index("by_playlist_key", ["playlistKey"]),

  songs: defineTable({
    playlistId: v.id("playlists"),
    orderIndex: v.number(),
    title: v.optional(v.string()),
    artistName: v.optional(v.string()),
    genre: v.optional(v.string()),
    subGenre: v.optional(v.string()),
    lyrics: v.optional(v.string()),
    caption: v.optional(v.string()),
    coverPrompt: v.optional(v.string()),
    coverUrl: v.optional(v.string()),
    coverStorageId: v.optional(v.id("_storage")),
    bpm: v.optional(v.number()),
    keyScale: v.optional(v.string()),
    timeSignature: v.optional(v.string()),
    audioDuration: v.optional(v.number()),
    vocalStyle: v.optional(v.string()),
    mood: v.optional(v.string()),
    energy: v.optional(v.string()),
    era: v.optional(v.string()),
    instruments: v.optional(v.array(v.string())),
    tags: v.optional(v.array(v.string())),
    themes: v.optional(v.array(v.string())),
    language: v.optional(v.string()),
    description: v.optional(v.string()),
    status: songStatusValidator,
    aceTaskId: v.optional(v.string()),
    aceSubmittedAt: v.optional(v.number()),
    audioUrl: v.optional(v.string()),
    storagePath: v.optional(v.string()),
    aceAudioPath: v.optional(v.string()),
    errorMessage: v.optional(v.string()),

    retryCount: v.optional(v.number()),
    erroredAtStatus: v.optional(songStatusValidator),
    cancelledAtStatus: v.optional(songStatusValidator),
    generationStartedAt: v.optional(v.number()),
    generationCompletedAt: v.optional(v.number()),
    isInterrupt: v.optional(v.boolean()),
    interruptPrompt: v.optional(v.string()),
    llmProvider: v.optional(llmProviderValidator),
    llmModel: v.optional(v.string()),
    promptEpoch: v.optional(v.number()),
    userRating: v.optional(v.union(v.literal("up"), v.literal("down"))),
    playDurationMs: v.optional(v.number()),
    listenCount: v.optional(v.number()),
    metadataProcessingMs: v.optional(v.number()),
    coverProcessingMs: v.optional(v.number()),
    audioProcessingMs: v.optional(v.number()),
  }).index("by_playlist", ["playlistId"])
    .index("by_playlist_status", ["playlistId", "status"])
    .index("by_playlist_order", ["playlistId", "orderIndex"]),

  settings: defineTable({
    key: v.string(),
    value: v.string(),
  }).index("by_key", ["key"]),
})
